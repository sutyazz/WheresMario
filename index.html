<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ME210 Winter 2025: Bots & Pans - Lab Report</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>ME210 Winter 2025: Bots & Pans - Lab Report</h1>
    <nav>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#software">Software Architecture</a></li>
        <li><a href="#hardware">Hardware Architecture</a></li>
      </ul>
    </nav>
  </header>
  
  <main>
    <!-- Introduction Section -->
    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This report details the software architecture and strategy implemented for our "Bots & Pans" robot project.
        Our approach utilized a master-slave Arduino setup with a custom communication protocol to create a robust autonomous
        system capable of navigating the kitchen environment, interacting with the pot, turning on the stove, and dropping
        ingredients as required by the competition rules.
      </p>
      <img src="images/robot-intro.jpg" alt="Bots & Pans Robot Project" />
    </section>
    
    <!-- Software Architecture Section -->
    <section id="software">
      <h2>Software Architecture Overview</h2>
      
      <!-- Master-Slave Configuration -->
      <article id="master-slave">
        <h3>Master-Slave Configuration</h3>
        <p>
          We implemented a distributed computing approach using two Arduino microcontrollers:
        </p>
        <ul>
          <li>
            <strong>Sensor Arduino (Master):</strong> Responsible for sensor data collection, state machine management,
            decision-making logic, and secondary motor control (ball drop and ignitor arm mechanisms).
          </li>
          <li>
            <strong>Motor Arduino (Slave):</strong> Dedicated to controlling the four-wheel drivetrain based on commands
            received from the master Arduino.
          </li>
        </ul>
        <img src="images/master-slave.jpg" alt="Master-Slave Configuration" />
      </article>
      
      <!-- Communication Protocol -->
      <article id="comm-protocol">
        <h3>Communication Protocol</h3>
        <p>
          The communication between the two Arduinos is managed by a custom serial protocol (defined in <code>SerialProtocol.h</code>)
          that includes:
        </p>
        <ul>
          <li>Structured message format with start/end bytes (0xFF/0xFE)</li>
          <li>Message type differentiation (commands, acknowledgments, errors)</li>
          <li>Data length and payload fields</li>
          <li>Checksum verification for error detection</li>
          <li>Timeout handling for reliable communication</li>
        </ul>
      </article>
      
      <!-- State Machine Design -->
      <article id="state-machine">
        <h3>State Machine Design</h3>
        <p>
          The core of our control system is a finite state machine implemented on the Sensor Arduino with the following states:
        </p>
        <ul>
          <li>IDLE_START: Initial waiting state that transitions to orientation after a brief delay</li>
          <li>INITIAL_ORIENTATION: Uses ultrasonic sensors to establish position relative to walls</li>
          <li>LOCATE_POT: Implements a search pattern to find the pot using IR sensors</li>
          <li>APPROACH_POT: Executes a sequence to move toward the detected pot</li>
          <li>PUSH_POT: A brute force alternative approach for pot location and positioning</li>
          <li>TURN_STOVE_ON: Controls the ignitor arm to activate the burner</li>
          <li>DROP_BALLS: Operates the ball drop mechanism to deliver ingredients</li>
          <li>BACK_TO_LOAD: Returns to the loading area for more ingredients</li>
          <li>BACK_TO_POT: Returns to the pot area to deliver ingredients</li>
          <li>END_STATE: Handles end-of-competition behaviors</li>
          <li>ERROR_STATE: Handles error conditions and attempts recovery</li>
          <li>DUCK_STATE: Emergency stop state</li>
        </ul>
      </article>
      
      <!-- Sensor Integration -->
      <article id="sensor-integration">
        <h3>Sensor Integration</h3>
        <h4>Ultrasonic Sensors</h4>
        <p>
          Four ultrasonic sensors (front, left, back, right) are used for wall detection during initial orientation,
          establishing proper positioning within the kitchen, and determining absolute position based on distance measurements.
          The <code>measureDistance()</code> function provides distance readings in centimeters, while
          <code>isProperlyOriented()</code> uses these readings to confirm correct positioning.
        </p>
        <h4>IR Sensors</h4>
        <p>
          Four IR sensors were constructed to detect the pot’s position. They detect the IR beacon on the pot (emitting at 3333 Hz for Side A or 909 Hz for Side B).
          While they worked when tested in isolation, during the robot’s strafing mechanism the IR signal was missed, leading us to
          code the robot to work independently of these sensors.
        </p>
        <img src="images/sensors.jpg" alt="Sensor Integration" />
      </article>
      
      <!-- Motor Control Strategy -->
      <article id="motor-control">
        <h3>Motor Control Strategy</h3>
        <p>
          The motor control system implements several basic movement functions including forward/backward, left/right lateral (strafing),
          and rotational movement. Each motor is controlled independently using the <code>setMotor()</code> function, allowing for holonomic
          (omnidirectional) movement.
        </p>
        <h4>Safety Features</h4>
        <ul>
          <li>Global timeout (130 seconds) after which all motors and speakers are stopped</li>
          <li>Command timeout checking with error state transition</li>
          <li>Emergency stop capability via the main power switch</li>
          <li>Acknowledgment system to verify command execution</li>
        </ul>
      </article>
      
      <!-- Key Software Components -->
      <article id="key-components">
        <h3>Key Software Components</h3>
        <h4>Initial Orientation Logic</h4>
        <p>
          The orientation system rotates the robot until both left and back walls are detected, then executes a sequence of movements
          to establish a known position before moving to the next state.
        </p>
        <h4>Pot Finding Strategy</h4>
        <p>
          Two methods were implemented:
        </p>
        <ul>
          <li>
            <strong>Sensor-based method (LOCATE_POT and APPROACH_POT):</strong> Uses IR sensors and alternating strafing to locate the pot.
          </li>
          <li>
            <strong>Predefined movement method (PUSH_POT):</strong> Uses a six-step sequence without relying on sensor feedback.
          </li>
        </ul>
        <h4>Ball Delivery Cycle</h4>
        <p>
          A full ingredient delivery cycle is implemented: drop balls, return to load, and then return to the pot.
          After 8 cycles, the system transitions to the <em>END_STATE</em>.
        </p>
        <h4>End-of-Competition Behavior</h4>
        <p>
          The <em>END_STATE</em> handles the final movements: creating space, toggling the ignitor arm to turn off the burner,
          and moving toward the customer area.
        </p>
        <h4>Timing and Synchronization</h4>
        <p>
          Non-blocking timing using <code>millis()</code> and a global timeout ensure sensor monitoring and state transitions
          continue smoothly. Commands that exceed 5 seconds without acknowledgment trigger error recovery.
        </p>
        <h4>Communication Flow</h4>
        <p>
          The master Arduino sends a command with parameters, the slave executes it and sends an acknowledgment, and the master
          processes this acknowledgment before moving to the next command.
        </p>
        <h4>Error Handling and Recovery</h4>
        <p>
          Mechanisms include command timeouts, error state transitions, checksum verification, and a global timeout. If an error is detected,
          all motors stop, the system enters <em>ERROR_STATE</em>, waits briefly, and then attempts to restart from
          <em>INITIAL_ORIENTATION</em>.
        </p>
      </article>
      
      <!-- Conclusion -->
      <article id="conclusion">
        <h3>Conclusion</h3>
        <p>
          Our software strategy prioritized reliability, modularity, and robustness. The master-slave architecture combined with a state machine design
          enabled the system to manage complex sequences while recovering from errors. The custom communication protocol ensured reliable operation
          between the Arduinos and the cyclical ball delivery maximized scoring opportunities.
        </p>
        <p>
          Future improvements include advanced sensor fusion, dynamic path planning, PID control, machine learning for optimal strategy, enhanced communication,
          visual feedback, adaptive ball drop mechanisms, and improved error classification.
        </p>
      </article>
    </section>
    
    <!-- Hardware Architecture Section -->
    <section id="hardware">
      <h2>Hardware Architecture Overview</h2>
      
      <!-- Overview -->
      <article id="hardware-overview">
        <p>
          Our design initially implemented 9 sensors, 6 DC motors, 3 Motor Drivers, and a speaker/amplifier circuit.
        </p>
      </article>
      
      <!-- Sensors -->
      <article id="hardware-sensors">
        <h3>Sensors</h3>
        <h4>IMU (Inertial Measurement Unit)</h4>
        <p>
          We planned to use the accelerometer and gyroscope on this device to get an initial orientation of the robot so that it could correct its movements based on its known position.
          Ultimately, the IMU was too inaccurate to be used and we could not fix it in software, so we decided not to use this sensor.
        </p>
        <img src="images/hardware-imu.jpg" alt="IMU Sensor" />
        
        <h4>Ultrasonic Sensor</h4>
        <p>
          These sensors were placed low on the robot to sense the distances between the robot and the walls for initial orientation.
          They were also planned for later use during the round to help find the pantry and avoid collisions.
        </p>
        <img src="images/hardware-ultrasonic.jpg" alt="Ultrasonic Sensors" />
        
        <h4>IR Sensor</h4>
        <p>
          We implemented four IR sensors (from lab 1) for redundancy and a larger coverage area.
          The IR phototransistors have a 10-degree signal acceptance angle, so placing four sensors allowed better detection of the IR emitter.
          An alteration from the lab 1 circuit—increasing the gain by swapping for a larger resistor—improved the sensitivity and increased the sensing distance.
        </p>
        <img src="images/hardware-ir.jpg" alt="IR Sensors" />
      </article>
      
      <!-- Motors & Motor Drivers -->
      <article id="hardware-motors">
        <h3>Motors & Motor Drivers</h3>
        <p>
          We chose to use the DC motors and Motor Drivers from lab 2 due to their availability, our familiarity with them, low cost, and suitable speed/torque specifications.
          Although DC motors make it more challenging to track the robot’s position due to the inability to count wheel rotations, we opted to use sensor-based positioning instead.
        </p>
        <img src="images/hardware-motors.jpg" alt="Motors and Motor Drivers" />
      </article>
      
      <!-- Speaker and Amplifier Circuit -->
      <article id="hardware-speaker">
        <h3>Speaker and Amplifier Circuit</h3>
        <p>
          A speaker and amplifier circuit was used to play music during competition, fulfilling the requirement of having an electromechanical indication of operation.
          This approach was chosen because it was fun, simple to implement, and low-cost—especially since one team member had previously built the circuit for another class.
        </p>
        <img src="images/hardware-speaker.jpg" alt="Speaker and Amplifier Circuit" />
      </article>
      
      <!-- Hardware Design Rationale -->
      <article id="hardware-rationale">
        <h3>Hardware Design Rationale</h3>
        <p>
          Our initial game plan included most, if not all, of these sensors to allow for redundancy and multiple backup strategies.
          We implemented all the sensors from the more complex plan during the building phase so we could later choose which ones to use during testing.
          Ultimately, due to issues with some sensors and time constraints, we simplified the approach.
        </p>
      </article>
      
      <!-- Discussion -->
      <article id="hardware-discussion">
        <h3>Discussion</h3>
        <p>
          The circuit design was relatively straightforward, though we faced challenges such as fragile wire connections and selecting the correct pins on the Arduino.
          Wire connections were often compromised during battery connection/disconnection, so we used hot glue to secure them.
          Additionally, the Arduino Uno’s dedicated PWM pins (490Hz or 980Hz) were used to achieve more accurate speed control,
          after finding that software-based PWM on non-dedicated pins affected performance.
        </p>
      </article>
      
      <!-- Hardware Conclusion -->
      <article id="hardware-conclusion">
        <h3>Hardware Conclusion</h3>
        <p>
          In conclusion, the hardware solutions chosen for this project provide a robust foundation for reliable performance and future scalability.
          Each component—from the central processing unit to the specialized peripherals—was carefully evaluated based on functionality, compatibility,
          and longer-term needs. By balancing cost-effectiveness with technical capability, the hardware architecture met current requirements while leaving room for future upgrades.
          This selection not only achieved immediate performance benchmarks but also positions the project for more complex future implementations.
        </p>
      </article>
    </section>
  </main>
  
  <footer>
    <p>&copy; 2025 ME210 Lab Team. All rights reserved.</p>
  </footer>
  
  <script src="script.js"></script>
</body>
</html>
